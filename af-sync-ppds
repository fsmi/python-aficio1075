#!/usr/bin/python
# -*- coding: utf-8 -*-
# vim:set ft=python ts=4 sw=4 et:

# af-sync-ppds -- Update the list of available user codes in one or more PPD
#   files.
#
# Copyright (C) 2008, 2010 Fabian Knittel <fabian.knittel@avona.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA.

from optparse import OptionParser
from aficio1075 import accounts
from aficio1075 import config_utils
from ConfigParser import SafeConfigParser
import os
import pwd
import grp
import sys
import codecs

sys.stdout = codecs.getwriter('UTF-8')(sys.stdout)
sys.stderr = codecs.getwriter('UTF-8')(sys.stderr)


def stream_update_codes(in_f, out_f, codes):
    # Forcefully encode our unicode strings to the encoding used by the PPD.
    encoder = codecs.getencoder('latin1')
    enc_str = lambda s: encoder(s, 'replace')[0]

    within_code_ui = False
    for line in in_f:
        if not within_code_ui:
            if line.startswith('*OpenUI *Code'):
                within_code_ui = True
        else:
            if line.startswith('*Code '):
                # Skip the line.
                continue
            elif line.startswith('*CloseUI: *Code'):
                within_code_ui = False
                for code in codes:
                    out_f.write(enc_str('*Code %d/%s %d: "%% ' \
                            'FoomaticRIPOptionSetting: Code=%d"\n' % (
                            code[0], code[1], code[0], code[0])))
        out_f.write(line)

def read_codes(um, user_code_regions):
    accts = um.get_user_infos()

    # We only want accounts that may print.
    accts = filter(lambda acct: acct.restrict.grant_printer, accts)

    # Filter all user accounts.
    user_accts = filter(lambda acct: config_utils.user_code_within_regions(
            acct.user_code, user_code_regions), accts)
    user_accts.sort(key=lambda acct: acct.name)

    # Filter all non-user accounts.
    special_accts = filter(lambda acct:
            not config_utils.user_code_within_regions(acct.user_code,
                    user_code_regions), accts)
    special_accts.sort(key=lambda acct: acct.user_code)

    # Build list of user code and account name pairs.
    codes = [(acct.user_code, acct.name) for acct in special_accts]
    for acct in user_accts:
        # Does the user code have a matching UNIX account?
        try:
            pwentry = pwd.getpwuid(acct.user_code)
            name = unicode(pwentry.pw_gecos, 'utf-8')
        except KeyError:
            # For some reason, there is no matching UNIX account.  For our
            # purposes this is no big deal.
            name = acct.name
        codes.append((acct.user_code, name))

    return codes

def main():
    parser = OptionParser()
    parser.add_option("--config", action = "store", dest = "config_file",
            help = "Path of configuration file",
            default = config_utils.CONFIG_PATH)
    (options, args) = parser.parse_args()
    if len(args) != 0:
        parser.error("incorrect number of arguments")

    cf = SafeConfigParser()
    cf.read(options.config_file)

    if not cf.has_section('printer') or \
            not cf.has_option('printer', 'hostname'):
        parser.error("hostname not specified")
    if not cf.has_section('printer') or \
            not cf.has_option('printer', 'passwd'):
        parser.error("passwd not specified")

    if not cf.has_section('unix_sync'):
        parser.error("configuration file misses unix_sync section")
    if not cf.has_option('unix_sync', 'user_code_regions'):
        parser.error("user_code_regions not specified")
    else:
        user_code_regions = config_utils.str_to_code_regions(
                cf.get('unix_sync', 'user_code_regions'))

    if not cf.has_section('ppd_sync'):
        parser.error("configuration file misses ppd_sync section")
    if not cf.has_option('ppd_sync', 'ppd_files'):
        parser.error("valid_groups not specified")
    else:
        ppd_files = config_utils.comma_string_to_list(
                cf.get('ppd_sync', 'ppd_files'))

    um = accounts.UserMaintSession(host = cf.get('printer', 'hostname'),
            passwd = cf.get('printer', 'passwd'))

    # Read accounts from printer.
    codes = read_codes(um, user_code_regions)

    for ppd_file in ppd_files:
        f = open(ppd_file, 'rb')
        ft = open('new.ppd', 'wb')
        stream_update_codes(f, ft, codes)
        ft.flush()
        os.fsync(ft.fileno())
        ft.close()
        f.close()


if __name__ == '__main__':
    main()
